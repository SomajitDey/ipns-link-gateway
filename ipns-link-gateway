#!/usr/bin/env -S bash -O extglob
# Brief: Public IPFS http proxy
# Repo: https://github.com/SomajitDey/ipns-link
# Usage: PORT=<TCP port no.> MAX_CONNS=<max no. of simultaneous clients> ipns-link-gateway

export IPFS_PATH="${IPFS_PATH:="${HOME}/.ipns-link-gateway"}"
export cache_dir="${IPFS_PATH}/.cache"; mkdir -p "${cache_dir}"

is_expired(){
  # Brief: Check if given (cache) file is expired (exit code 0) or not (exit code 1).
  # Usage: is_expired <path_to_cache_file> <ttl in seconds>
  local file="${1}" ttl="${2}"
  ((EPOCHSECONDS-"$(date -r "${file}" +%s)" > ttl))
} &>/dev/null; export -f is_expired

cache_address(){
  # Brief: Cache multiaddress list.
  # Usage: cache_address <ipns_key>
  local ipns_key="${1}"
  local cache_file="$(ls ${cache_dir}/*_${ipns_key}_*)"
  if [[ -z "${cache_file}" ]] || is_expired "${cache_file}" 900; then
    local multiaddress_list
    multiaddress_list="$( # Gateways used to avoid using DHT, saving bandwidth. Multiple gateways for redundancy
      set -o pipefail
      (  
        curl -sf --max-filesize 1000 https://ipfs.io/ipns/"${ipns_key}"/ || \
        curl -sf --max-filesize 1000 https://gateway.ipfs.io/ipns/"${ipns_key}"/ || \
        curl -sf --max-filesize 1000 https://cloudfare-ipfs.com/ipns/"${ipns_key}"/ || \
        curl -sf --max-filesize 1000 https://gateway.pinata.cloud/ipns/"${ipns_key}"/ || \
        curl -sf --max-filesize 1000 https://hub.textile.io/ipns/"${ipns_key}"/ || \
        curl -sf --max-filesize 1000 https://ipfs.fleek.co/ipns/"${ipns_key}"/
      ) | sed -n '/<!--ipns-link--/,/--ipns-link-->/{//!p;}'
    )" || return 1
    grep -v '/p2p/[[:alnum:]]*' <<< "${multiaddress_list}" && return 1 # Wrong pattern
    local peerID="$(head -n1 <<< "${multiaddress_list}" | awk -F '/' '{print $NF}')"
    # TODO: TBD: Does the following need to be atomic using flock?
    if [[ -z "${cache_file}" ]]; then
      if cache_file="$(ls ${cache_dir}/*_${peerID}_*)"; then
        rm "${cache_file}"
        cache_file="${cache_file}${ipns_key}_"
      else
        cache_file="${cache_dir}/_${peerID}_${ipns_key}_"
      fi
    fi
    echo "${multiaddress_list}" > "${cache_file}"
  fi
} &>/dev/null; export -f cache_address

get_peerID(){
  # Brief: Get peerID corresponding to given ipns_key
  # Usage: get_peerID <ipns_key>
  [[ "$(ls ${cache_dir}/*_${1}_*)" =~ /_([[:alnum:]]+)_[^/]*$ ]] && echo "${BASH_REMATCH[1]}"
} 2>/dev/null; export -f get_peerID

connect(){
  # Brief: Get multiaddress to the given node from cache and connect.
  # Usage: connect <ipns_key or peerID>
  local ipns_key="${1}"
  local multiaddress
  for multiaddress in $(cat ${cache_dir}/*_${ipns_key}_*); do
    if ipfs swarm connect "${multiaddress}"; then
      read peer_addr relay_addr < <(grep -o '/p2p/[[:alnum:]]*' <<< "${multiaddress}" | tac | xargs)
      trap "disconnect ${peer_addr} ${relay_addr}" exit
      break
    else
      false # To make the error code non-zero when swarm connect fails
    fi
  done
} &>/dev/null; export -f connect

disconnect(){
  # Brief: Disconnect given peer and relay. Disconnect relay only if no other peer is using it
  # Usage: disconnect </p2p/peer_addr> </p2p/relay_addr>
  local peer_addr="${1}" relay_addr="${2}"
  (
    flock -F -n 3 || exit 1
    ipfs swarm disconnect "${peer_addr}" # Disconnect from peer
    if [[ -n "${relay_addr}" ]]; then
      ipfs swarm peers | grep -q -m1 "${relay_addr}/p2p-circuit" || ipfs swarm disconnect "${relay_addr}"
    fi
  ) 3<${cache_dir}/*_${peer_addr/\/p2p\//}_*
} &>/dev/null; export -f disconnect

error(){
  # Brief: Pass HTTP error to client. When no error, serve index.html, if any
  # Usage: error [code] [reason-phrase/status]
  local code="${1:-404}" msg="${2:-Not found}"
  printf "%s\r\n" "HTTP/1.1 ${code} ${msg}"
  printf "Content-Length: %d\r\n" "${#msg}"
  printf "\r\n%s\r\n" "${msg}"
  exit
} 2>/dev/null; export -f error

serve(){
  # Brief: Serve resource/webpage at the given path
  # Usage: serve <path>
  local page="${1:-index.html}"
  [[ -f "${page}" ]] || error
  printf "%s\r\n" "HTTP/1.1 200 OK"
  printf "Content-Length: %d\r\n" "$(wc -c "${page}" | cut -d' ' -f1)"
  cat <(echo -e \\r) "${page}" <(echo -e \\r)
  exit
} 2>/dev/null; export -f serve

redirect(){
  # Brief: Pass HTTP redirect to client
  # Usage: redirect <(relative) URL>
  local url="${1}"
  printf "%s\r\n" "HTTP/1.1 307 Temporary Redirect" # 307 makes sure Method and Body remain unchanged on redirect
  printf "Cache-Control: %s\r\n" "no-store,max-age=0"
  printf "Location: %s\r\n" "${url}"
  local msg="<a href=${url}>Redirect</a>"
  printf "Content-Length: %d\r\n" "${#msg}"
  printf "\r\n%s\r\n" "${msg}"
  exit
} 2>/dev/null; export -f redirect

rate_limiter(){
  # Brief: Rate limiter
  # Usage: rate_limiter <clientIP>
  local allowed=20 interval=60 # Allowed n connections from any given IP per m seconds
  local file="${cache_dir}/${1}_$((EPOCHSECONDS/interval))"
  local count="$(wc -l "${file}" | cut -d' ' -f1)"
  (( count < allowed )) && date +%D\ %H:%M:%S >> "${file}"
} &>/dev/null; export -f rate_limiter

visitor_count(){
  # Brief: Log no. of users/visitors since server went up
  # Usage: visitor_count
  local log=./.visitor_count.txt
  local count="Visitor-count: $(awk '{print $NF+1}' "${log}")"
  flock -F "${log}" tee "${log}" <<< "${count}"
} >&2; export -f visitor_count

process_head(){
  # Brief: Read the head part from the incoming http request from stdin and do the following:
  ## Hold new headers in var "headers"
  ## Set the "method", "path", "version", "host" and "referer" variables
  ## Remove X-Forwarded-For to hide client IP
  ## If there is no X-Forwarded-Host in the incoming request, set it to current host and X-Forwarded-Port to current port
  ## Does DNSLink resolution. Sets the "inject_cookie_path" flag
  read -rd $'\r\n' method path version && read # Reading the complete start-line
  local input="$(sed -u '/^\r$/q')" # Load current headers, including the delimiting blank line
  # "host" is current X-Forwarded-Host, assuming reverse proxies didn't preseve Host:
  # If there is no X-Forwarded-Host currently, then retrieve "host" from Host:
  local buffer
  if ! host="$(set -o pipefail; grep -i -m1 '^X-Forwarded-Host:' <<< "${input}" | awk '{print $2}' | tr -d \\r)"; then
    host="$(grep -i -m1 '^Host:' <<< "${input}" | awk '{print $NF}' | tr -d \\r)"
    buffer="$(grep -vi '^X-Forwarded-Port:' <<< "${input}" | \
    sed "3aX-Forwarded-Host: ${host%:*}\r\nX-Forwarded-Port: ${host##*:}\r")"
  fi
  # Put Host: localhost and delete X-Forwarded-For:
  headers="$(sed '/^X-Forwarded-For:/Id; /^Host:/IcHost: localhost\r' <<< "${buffer:-"${input}"}")"
  # The I modifer above (for case-insensitive regex) is for GNU sed only
  # With referer-policy: strict-origin-when-cross-origin
  # Read the /p2p/key/http part from the Referer header and store in the referer variable
  local referer_header="$(grep -i -m1 '^Referer:' <<< "${input}")"
  [[ "${referer_header}" =~ (http(s)?://[^/]+)(/p2p/[[:alnum:]]+/http) ]]
  referer="${BASH_REMATCH[3]}"
  # DNSLink
  local peerID domain="${host%:*}" # domain is host without :port
  if dig +short TXT _dnslink."${domain}" | grep -q -m1 'dnslink='; then
    cache_address "${domain}" || redirect https://ipfs.io/ipns/"${domain}"
    peerID="$(get_peerID "${domain}")"
    path="/p2p/${peerID}/http${path}"
    inject_cookie_path=false
  else
    inject_cookie_path=true
  fi
} >/dev/null; export -f process_head

inject_response_headers(){
  # Brief: Inject or modify certain headers in the http response message. Specifically the following
  ## Put the /p2p/peerID/http prefix in cookie-path so that cookies are sent only to peerID
  ## Remove Domain attribute from Set-Cookie header for Cross-origin safety. # TODO: TBD:
  ## Enforce Referer-Policy such that Referer headers contain peerID - solves root-relative-URL problem.
  # Usage: inject_response_headers <cookie_path>
  local cookie_path="${1//\//\\\/}"
  local input="$(sed -u '/^\r$/q')" # Load current headers, including the delimiting blank line
  local buffer
  if "${inject_cookie_path}"; then
    buffer="$(sed "/^Set-Cookie:/I{s/Path=/Path=${cookie_path}/gi;s/Domain=[^;]*//gi}" <<< "${input}")"
  fi
  grep -v -i '^Referrer-Policy:' <<< "${buffer:-"${input}"}" | \
    sed '3aReferrer-Policy: strict-origin-when-cross-origin\r'
  cat # To pass on the response body
}; export -f inject_response_headers

handler(){
  # Brief: Main handler routine spawned by server on new connection from client.
  # Usage: handler <ipfs_gateway_port>
  rate_limiter "${SOCAT_PEERADDR}" || error 429 "Too many requests"
  local method path version headers host referer inject_cookie_path gateway_port="${1}"
  process_head
  echo -e "\nLog: $(date +%D\ %H:%M:%S)\nIP: ${SOCAT_PEERADDR}\nHost: ${host}\nMethod: ${method}\nPath: ${path}" >&2
  echo "Referer: ${referer}" >&2
  visitor_count
  if [[ "${path}" =~ ^/p2p/([[:alnum:]]+)/http(/.*)?$ ]]; then
      [[ -n "${BASH_REMATCH[2]}" ]] || redirect "${path}/"
    # Format 1: The path format that IPFS gateway works with. Every other format redirects to this
      local ipns_key="${BASH_REMATCH[1]}"
      cache_address "${ipns_key}" || error
      if flock -F -s 3 && connect "${ipns_key}"; then
        cat <(printf "%s\r\n%s\n" "${method} ${path} ${version}" "${headers}") - | \
          nc -q 5 localhost "${gateway_port}" | \
          inject_response_headers "/p2p/${ipns_key}/http"
          # TODO: Why -q5 in `nc`. Conjures with -T30 in `socat` below. Without these timeouts connections are kept alive indefinitely.
      else
        error
      fi 3<${cache_dir}/*_${ipns_key}_*
  elif [[ "${path}" =~ ^/(ipns/|\?ipns-link-gateway=)([-[:alnum:].]+)((/|%2f|%2F).*)?$ ]]; then
    # Format 2: Exists for user convenience. Redirect to format 1
      local ipns_key="${BASH_REMATCH[2]}"
      cache_address "${ipns_key}" || redirect https://ipfs.io/ipns/"${ipns_key}"
      local peerID="$(get_peerID "${ipns_key}")"
      redirect /p2p/"${peerID}"/http/"${BASH_REMATCH[3]#${BASH_REMATCH[4]}}"
  else
    # Format 3: Exists due to root-relative URLs in served websites. Path doesn't have ipns-name or peerID.
    # Retrieve peerID from Referer header (see "referer" above) & redirect to format 1
      if [[ -n "${referer}" ]]; then
        redirect "${referer}${path}"
      else
        serve "${path#/}"
      fi
  fi
}; export -f handler

init(){
  # Brief: Launches daemon & gives gateway_port.
  # Note: All ports are randomly chosen to allow multiple IPFS nodes on the same machine
  if [[ "$(ipfs config App)" != "ipns-link-gateway" ]]; then
    ipfs init --profile server || ipfs config profile apply server # Disallow local discovery & private IPs
    ipfs bootstrap rm all
    ipfs config Routing.Type none
    ipfs config Swarm.ConnMgr.Type none
    ipfs config --json Experimental.P2pHttpProxy true
    ipfs config --json Gateway.NoFetch true
    ipfs config --json Gateway.NoDNSLink true
    ipfs config --json Gateway.PublicGateways '{"localhost": {"Paths":["/p2p"],"UseSubdomains": false}}'
    ipfs config App ipns-link-gateway
  fi
  ipfs config profile apply randomports; rm -f "${IPFS_PATH}/config-pre-"*
  pscan(){
    # Brief: Give an unused, random, local TCP port except the one passed as argument
    local port except="${1}"
    while port="${RANDOM}";do # Max RANDOM=32767
      ((port!=except)) || continue
      nc -z localhost "${port}" || break
    done
    echo "${port}"
  } 2>/dev/null; export -f pscan
  RANDOM="${EPOCHSECONDS}" # Time dependent seed
  local API_port="$(pscan)"; ipfs config Addresses.API "/ip4/127.0.0.1/tcp/${API_port}"
  gateway_port="$(pscan "${API_port}")"; ipfs config Addresses.Gateway "/ip4/127.0.0.1/tcp/${gateway_port}"
  [[ "$(ipfs daemon | grep -iom1 'Daemon is ready' & tail -f --pid=$! /dev/null)" ]] # Launcher
} &>/dev/null; export -f init

# Only execute functions defined above
if [[ -n "${@}" ]]; then
  "${@}"
  exit "${?}"
fi

if init; then
  echo "Status: Launched IPFS daemon. Gateway port: ${gateway_port}"
else
  echo "Error: Failed to launch IPFS daemon"
  exit
fi >&2

server_port="${PORT:-8080}"; max_conns="${MAX_CONNS:-500}"
: > ./.visitor_count.txt # TODO: Make this filename a global variable
trap 'rm -rf ${cache_dir}/*' exit

echo "Status: Listening for connections at port ${server_port} ..." >&2
socat -T30 TCP4-LISTEN:"${server_port}",max-children="${max_conns}",fork,reuseaddr \
  SYSTEM:"${BASH_SOURCE} handler ${gateway_port}"
echo -e "\nStatus: Exiting ..." >&2
